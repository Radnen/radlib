/**
* Script: parsetest.js
* Written by: Radnen
* Updated: 3/31/2013
**/

RequireScript("radlib/radlib.js");
RequireScript("radlexer.js");
RequireScript("radparser.js");

const ERROR      = -2;
const WHITESPACE = -1;
const COMMENT    = 0;
const NUM        = 1;
const PRINT      = 2;

/* This defines *my* language: */

RadLexer.register(/^[0-9]+$/, NUM);
RadLexer.register(/^print$/, PRINT);
RadLexer.register(/^#[^\n\r]*$/, COMMENT);
RadLexer.register(/^+$/, '+');
RadLexer.register(/^-$/, '-');
RadLexer.register(/^*$/, '*');
RadLexer.register(/^\/$/, '/');
RadLexer.register(/^;$/, ';');
RadLexer.register(/^[\s]+$/, WHITESPACE);
RadLexer.register(/^[^ \n\r]+$/, ERROR);

/* This lexes a file: */
RadLexer.lex("test.radscript");

/* This defines *my* semantics: */

/*function Print(expr) {
	this.expr = expr;
}

Print.prototype.eval = function() {
	Abort(this.expr.eval());
}

function BinExpr(type, left, right) {
	this.t = type.tok;
	this.left = left;
	this.right = right;
}

BinExpr.eval = function() {
	var l = this.left.eval();
	var r = this.right.eval();
	switch (this.t) {
		case '+': return l + r;
		case '-': return l - r;
		case '*': return l * r;
		case '/': return l / r;
	}
}

function Expr() {
	
}

RadParser.register(PRINT, EXPR, ';', function(a, b, c) { return new Print(b); });
RadParser.register(EXPR, '+', EXPR, function(a, b, c) { return new BinExpr(b, a, c); });
RadParser.register(EXPR, '-', EXPR, function(a, b, c) { return new BinExpr(b, a, c); });
RadParser.register(EXPR, '*', EXPR, function(a, b, c) { return new BinExpr(b, a, c); });
RadParser.register(EXPR, '/', EXPR, function(a, b, c) { return new BinExpr(b, a, c); });
RadParser.register(NUM, function(a) { return new IntLit(a); });


/* This parses those tokens: */
//RadParser.parse(RadLexer.tokens);*/

/* This parses the tree generated by the parser: */
// RadInterpreter.run(RadParser.tree);

/* This does the above 3 at once: */
// RadInterpreter.execute("scripttest.radscript");